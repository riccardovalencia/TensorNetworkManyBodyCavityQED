import sys
sys.path.append("../library_python")
import Hamiltonian_light_matter as Hlm
import bosonic_operators as bo
import su2_spins_operators as su2
from quimb.tensor import *
from quimb import *
from quimb.evo import *
import numpy as np
from scipy.integrate import ode
import matplotlib.pyplot as plt

folder = "."

# Rydberg in cavity. We consider a system of N Rybderg atoms coupled to a single-mode cavity field.
# The atoms are described by two-level systems with
# |down_z> = |1> (Rydberg state)
# |up_z>   = |0> (ground state)

# Mostly used for benchmarking tensor network methods -> curse of dimensionality does not allow
# to explore large systems.

# dynamics of the open Dicke model with Rydberg interactions and lossy cavity 
# (jump operatorL = \sqrt{k}a, with a -> bosonic annihilation operator)
# dynamics generated by the Lindbland master equation
# \dot{rho} = -i[H,\rho] + k (a \rho a^dag - a^\dag a \rho - \rho a^\dag a),
# where rho is the density matrix representing the photon + matter
# H = om_ph a^dag a  
#   + om_z \sum_j \sigma_j^z
#   + V \sum_j n_j n_{j+1} 
#   + g/sqrt{N} (a+a^\dag)\sum_j \sigma_j^x,
# where: \sigma_j^\alpha is the alpha-Pauli matrix acting on site j
#        n_j = (1-\sigma_j^z)/2 = |down_z\rangle \langle \down_z| (projector)
 
# parameters
sparse = False
# system size
L = 3
# max occupation of the bosonic degree of freedom (photon)
MaxOcc = 2
# photon frequency
om_ph  = 1
# atom splitting
om_z   = 0.6
# decay rate of the photon
kappa  = 1.6
# rydberg-rydberg interaction
V = 0.5
# mean field critical photon-matter coupling for V=0
gc     = np.sqrt( 0.5 * om_z * (om_ph**2 + (kappa/2)**2) / om_ph )
# photon-matter coupling
g = gc * 1.6 / np.sqrt(L)
# total time
T   = 15
# time step
dt  = 0.01



fig, axs = plt.subplots(1,2,figsize=(12,6))


def mine_lindblad_eq(t,y,args):

    ham     = args[0]
    ls      = args[1]
    gamma   = args[2]

    d = ham.shape[0]
    ham_sparse = issparse(ham) or sparse
    idt = eye(d, sparse=ham_sparse)
    evo_superop = -1.0j * ((ham & idt) - (idt & ham.T))

    def gen_lb_terms():
        for l in ls:
            lb_sparse = issparse(l) or sparse
            idt = eye(d, sparse=lb_sparse)
            yield ((l & l.conj()) - 0.5 * ((idt & dot(dag(l), l).T) + (dot(dag(l), l) & idt)))
                                           
    evo_superop += gamma * sum(gen_lb_terms())
    return dot(evo_superop, y)





# dynamics parameters
ts = np.linspace(dt,T,num=int(T/dt))
dims = [MaxOcc+1 ] + [2]*L 

# operators
Nph = bo.Nb(MaxOcc,sparse)
Xph = bo.Ab(MaxOcc,sparse) + bo.Abd(MaxOcc,sparse)

X  = pauli('X',sparse=sparse)
Z  = pauli('Z',sparse=sparse)
I  = pauli('I',sparse=sparse)
N  = (I-Z)/2.
Sx = ikron(X  ,dims=dims,inds=[1])
Nb = ikron(Nph,dims=dims,inds=[0])
# initiail state
psi_ph = qu([1] + [0 for j in range(MaxOcc)]     , qtype='ket', sparse=sparse)
psi_j  = qu(np.array([1/np.sqrt(2),1/np.sqrt(2)]), qtype='ket', sparse=sparse)

psi_t0 = psi_ph
for _ in range(L):
    psi_t0 = psi_t0 & psi_j

# free component
H = 0
for j in range(1,L+1):
    H += om_z * ikron(Z,dims,inds=[j])
H += om_ph * ikron(Nph,dims,inds=[0]) 
 
# matter-matter interaction
for j in range(1,L):
    H += V * pkron(N & N , dims , inds=[j,j+1])

# light-matter component
for j in range(1,L+1):
    H +=  g * pkron(Xph & X,dims,inds=[0,j])


# list where to save results
sx_t   = []
np_t   = []
data_t = []

if kappa <= 1E-10:
    evo = Evolution(psi_t0, H, progbar=True,method='integrate')
    for idx, psi_t in enumerate(evo.at_times(ts)):
        np_t += [np.real(expec(psi_t,Nb))/L]
        sx_t += [np.real(expec(psi_t,Sx))]
        data_t += [[ts[idx],sx_t[-1],np_t[-1]]]
        
else:
    # build up the density matrix
    rho_t0 = outer(psi_t0,psi_t0.H)
    rho_t0 /= trace(rho_t0)
    D = prod(dims)

    l = bo.Ab(MaxOcc,sparse)
    Lj = [ikron(l, dims, inds = [0])]

    # setting the integrator
    integrator_solver = ode(mine_lindblad_eq).set_integrator('zvode', method='bdf',rtol=1E-10)
    integrator_solver.set_f_params([H,Lj,kappa])
    integrator_solver.set_initial_value(rho_t0.reshape(D**2))

    # integration
    tau = dt
    n_measure = 10

    for idx_t, t in enumerate(ts):
        print(t)    
        rhot = integrator_solver.integrate(t)
        rhot = rhot.reshape(D,D)

        rhot /= trace(rhot)

        np_t += [np.real(expec(rhot,Nb))/L]
        sx_t += [np.real(expec(rhot,Sx))]
        data_t += [[t,sx_t[-1],np_t[-1]]]

np.savetxt(f"{folder}/obs_interacting_dicke_ED_N{L}_maxocc{MaxOcc}_omega{om_ph:.2f}_h{om_z:.2f}_V{V:.2f}_g{g:.2f}_kappa{kappa:.2f}.txt",data_t)

#     axs[0].plot(ts,np_t,linestyle='-',label=f'{g:.2f}')
#     np_infty += [np_t[-1]]
# axs[0].legend()
# axs[1].plot(g_list,np_infty,marker='o',linestyle='--',color='black')
# axs[1].plot(gc,0,marker='x',color='tab:red')
# plt.show()

# folder = "test_ising/"
# folder = "/home/ricval/Documenti/projects_in_progress/edge_modes_tfic/data/non_integrable/ED_data/"
# np.savetxt(f'{folder}ED_Ising_Mixed_N{L}_Jxx{Jxx:.3f}_hx{hx:.3f}_gamma{gamma:.3f}_exact{exact}.txt',data_t)


