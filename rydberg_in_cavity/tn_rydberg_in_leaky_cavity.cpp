#include <itensor/all.h>
#include <sys/stat.h>
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <math.h>       /* exp */
#include <fstream>	//output file
#include <sstream>	//for ostringstream
#include <iomanip>
#include "../library_cpp/spin_boson.h"
#include <filesystem>

using namespace std;
using namespace itensor;
namespace fs = std::filesystem;

// Rydberg in cavity. We consider a system of N Rybderg atoms coupled to a single-mode cavity field.
// The atoms are described by two-level systems with
// |down_z> = |1> (Rydberg state)
// |up_z>   = |0> (ground state)

// dynamics of the open Dicke model with Rydberg interactions and lossy cavity 
// (jump operator L = \sqrt{k}a, with a -> bosonic annihilation operator)
// dynamics generated by the Lindbland master equation
// \dot{rho} = -i[H,\rho] + k (a \rho a^dag - a^\dag a \rho - \rho a^\dag a),
// where rho is the density matrix representing the photon + matter
// H = om_ph a^dag a  
//   + om_z \sum_j \sigma_j^z
//   + V \sum_j n_j n_{j+1} 
//   + g/sqrt{N} (a+a^\dag)\sum_j \sigma_j^x,
// where: \sigma_j^\alpha is the alpha-Pauli matrix acting on site j
//        n_j = (1-\sigma_j^z)/2 = |down_z\rangle \langle \down_z| (projector)
 
// Since dissipative channel acts only on the photon, we can unfold the density matrix in a bra-ket space
// (third quantization), making the algorithm more efficient as the density matrix is encoded in a MPS


// Benchmarked against dicke_model_tn.cpp for kappa = 0 : SUCCESS

//------------------------------------------------------------------MAIN--------------------------------------------------------------------

int main(int argc , char* argv[]){
	

    if(argc != 2)
    {
        cerr << "Passed wrong number of arguments.\n";
        exit(-1);
    }

    InputGroup input = InputGroup(argv[1],"input");
    int N           = input.getInt("N",3); // length
    int max_occ     = input.getInt("max_occ",2); // number of fermions up spin
    double omega0   = 1.; // photon frequency (energy scale set equal to 1)
    double h        = input.getReal("h",1);
    double g_ratio  = input.getReal("g",1.6);
    double V        = input.getReal("V",0.5);
    double kappa    = input.getReal("kappa",1);
    double T        = input.getReal("T",15);
    double dt       = input.getReal("dt",0.01);
    double cut_off  = input.getReal("cut_off",1E-14);
    int maxDim      = input.getInt("maxDim",1024);
    string initial_state = input.getString("initial_state","spin_coherent_state");
    
    // mean field value of the critical photon-matter coupling
    double gc = sqrt(0.5 * (abs(h)-V) * (omega0*omega0 + kappa*kappa/4.) / omega0 );

    double g   = g_ratio * gc;

    bool dissipative = (kappa > 1E-10);

    // observables to measure
    vector<string> name_obs;
    name_obs.push_back("fidelity");
    name_obs.push_back("Sx");
    name_obs.push_back("Sz");
    name_obs.push_back("Na");
    name_obs.push_back("MaxD");
    name_obs.push_back("local_obs");

    // spin coherent state (theta is the polar angle, phi is the azimuthal angle)
    double theta = 0.9 * M_PI;
    double phi   = 0.;

    int steps_measure = 1;
    if (dt < 0.01) steps_measure = int(0.01/dt);
    int total_steps = int(T / dt);

    SiteSet sites_single = custom_spin_boson(N+1,max_occ);
    MPS psi = initialize_spin_boson_state(sites_single , 0 , theta, phi);
    
    // measuring expectation values on initial state
    cerr << "Magnetization along x" << endl;
    vector<double> mj = measure_magnetization(&psi,sites_single,"x");
    for(double m : mj) cerr << " " << m ;
    cerr << "\nMagnetization along z" << endl;
    mj = measure_magnetization(&psi,sites_single,"z");
    for(double m : mj) cerr << " " << m ;
    cerr << "\n";

    // doubling space from ket to bra-ket space as:
    // bra (first half of the chain) - ket (second half of the chain)
    // The bra is inverted and dag in space with respect to the ket. 
    // Example for N = 4
    //  |    |    |   |   |    |    |    |
    // s3 - s2 - s1 - b - b - s1 - s2 - s2
    // | ---- bra ---- |  | ---- ket ---- |

    SiteSet sites = custom_spin_boson_doubling(N+1,max_occ);
    MPS psi_t = randomMPS(sites);    
    // inserting bra (it gets inverted and dag) between [1,N]
    insert_state(&psi_t, psi, 1,   true , true);
    // inserting ket bewteen [N+1,2*N]
    insert_state(&psi_t, psi, N+2, false, false);

    // normalization
    double  norm = compute_norm_purifed_impurity(&psi_t);
    psi_t /= norm;

    // operators of interest
    Index sph   = sites(N+2);
    Index sph_p = prime(sites(N+2));
    ITensor Nb  = ITensor(sph,sph_p);
    
    for(int d=1; d <= dim(sph) ; d++) Nb.set( sph(d)  ,sph_p(d),d-1);
    
    sph   = sites(1);
    sph_p = prime(sites(1));

    ITensor Sx = ITensor(sph,sph_p);
    ITensor Sz = ITensor(sph,sph_p);

    Sx.set(sph(1),sph_p(2),1.);
    Sx.set(sph(2),sph_p(1),1.);	
              
    Sz.set(sph(1),sph_p(1),1.);
    Sz.set(sph(2),sph_p(2),-1.);

    vector<complex<double> > number_photons = measure_local_obs_impurity_first_site(&psi_t , Nb, false, 1);
    vector<complex<double> > mj_x  = measure_local_obs_impurity_first_site(&psi_t , Sx, false, 2);
    vector<complex<double> > mj_z  = measure_local_obs_impurity_first_site(&psi_t , Sz, false, 2);
    
    // jump operator acting on th first physical site of the MPS 
    // (in this case it is the bosonic degree of freedom)

    vector<ITensor> Lj;
    int impurity_sites[2] = {N+1,N+2};
    for(int j : impurity_sites)
    {
        sph   = sites(j);
	    sph_p = prime(sites(j));
        ITensor A  = ITensor(sph,sph_p);

        for(int d=1; d < dim(sph) ; d++)
        {
            A.set( sph(d+1)  ,sph_p(d),sqrt(d));
        }
        Lj.push_back( A ); 
    }

    // build gates for ket
    vector<BondGate> gates_matter_single;
    vector<BondGate> gates_pm_single;
    vector<MyBondGateDiss> gates_D;

    if(dissipative)
    {
        gates_matter_single = gates_photon_matter(sites_single , omega0 ,h , g/sqrt(N), dt/2., "short-range","dicke",V);
        gates_pm_single     = gates_photon_matter(sites_single , omega0 ,h , g/sqrt(N), dt/2., "long-range","dicke");
        gates_D = gates_dissipative_impurity(sites , Lj, kappa , dt);
    }              
    else
    {
        gates_matter_single = gates_photon_matter(sites_single , omega0 ,h , g/sqrt(N), dt, "short-range","dicke",V);
        gates_pm_single     = gates_photon_matter(sites_single , omega0 ,h , g/sqrt(N), dt, "long-range","dicke" );
    }
    cerr << "Built the gates.\n";
    // using the gates above to define the gates of our interest
    vector<MyBondGate> gates_matter;
    vector<MyBondGate> gates_pm;

    // gates for performing time evolution in the doubled space

    // gates_matter = doubling_space_gates(gates_matter_single, sites_single,  sites);
    // gates_pm     = doubling_space_gates(gates_pm_single    , sites_single,  sites);

    // ket dynamics
    for( BondGate g : gates_matter_single)
    {
        // physical space position
        int i1 = g.i1();
        int i2 = g.i2();
        // position along the doubled space
        int inew_1 = N + 1 + i1;
        int inew_2 = N + 1 + i2;
        
        ITensor gate = g.gate();
        Index si1 = sites_single(i1);
        Index si2 = sites_single(i2);
        Index sinew1 = sites(inew_1);
        Index sinew2 = sites(inew_2); 

        // changed sites
        gate *= delta(si1,sinew1);
        gate *= delta(si2,sinew2);
        gate *= delta(prime(si1),prime(sinew1));
        gate *= delta(prime(si2),prime(sinew2));
        
        MyBondGate gnew = MyBondGate(sites,{inew_1,inew_2},0,gate);
        gnew.modify_gate(gate);
        gates_matter.push_back(gnew);
    }

    // bra dynamics
    for( BondGate g : gates_matter_single)
    {
        // physical space position
        int i1 = g.i1();
        int i2 = g.i2();
        // position along the doubled space
        int inew_1 = N + 2 - i1;
        int inew_2 = N + 2 - i2;
        
        ITensor gate = g.gate();
        Index si1 = sites_single(i1);
        Index si2 = sites_single(i2);
        Index sinew1 = sites(inew_1);
        Index sinew2 = sites(inew_2); 

        // changed sites
        gate *= delta(si1,sinew1);
        gate *= delta(si2,sinew2);
        gate *= delta(prime(si1),prime(sinew1));
        gate *= delta(prime(si2),prime(sinew2));
        // gate = swapPrime(gate,0,1); // NOT SURE

        
        MyBondGate gnew = MyBondGate(sites,{inew_1,inew_2},0,gate);
        gnew.modify_gate(dag(gate));
        gates_matter.push_back(gnew);
    }

    // ket dynamics
    for( BondGate g : gates_pm_single)
    {
        // physical space position
        int i1 = g.i1();
        int i2 = g.i2();
        // position along the doubled space
        int inew_1 = N + 1 + i1;
        int inew_2 = N + 1 + i2;
        
        ITensor gate = g.gate();
        Index si1 = sites_single(i1);
        Index si2 = sites_single(i2);
        Index sinew1 = sites(inew_1);
        Index sinew2 = sites(inew_2); 

        // changed sites
        gate *= delta(si1,sinew1);
        gate *= delta(si2,sinew2);
        gate *= delta(prime(si1),prime(sinew1));
        gate *= delta(prime(si2),prime(sinew2));
        
        MyBondGate gnew = MyBondGate(sites,{inew_1,inew_2},0,gate);
        gnew.modify_gate(gate);
        gates_pm.push_back(gnew);
    }

    // bra dynamics
    for( BondGate g : gates_pm_single)
    {
        // physical space position
        int i1 = g.i1();
        int i2 = g.i2();
        // position along the doubled space
        int inew_1 = N + 2 - i1;
        int inew_2 = N + 2 - i2;
        
        ITensor gate = g.gate();
        Index si1 = sites_single(i1);
        Index si2 = sites_single(i2);
        Index sinew1 = sites(inew_1);
        Index sinew2 = sites(inew_2); 

        // changed sites
        gate *= delta(si1,sinew1);
        gate *= delta(si2,sinew2);
        gate *= delta(prime(si1),prime(sinew1));
        gate *= delta(prime(si2),prime(sinew2));
        // gate = swapPrime(gate,0,1); // NOT SURE

        MyBondGate gnew = MyBondGate(sites,{inew_1,inew_2},0,gate);
        gnew.modify_gate(dag(gate));
        gates_pm.push_back(gnew);

    }

    cerr << "All gates initialized.\n";
  
    // keeping a copy of the initial state
    MPS psi_t0 = psi_t;
    vector<double> overlap_t;

    cerr << setprecision(10);

    string file_obs    = tinyformat::format("obs_RLC_N%d_maxocc%d_omega%.2f_h%.2f_gratio%.2f_V%.2f_kappa%.2f_maxDim%d.txt", N, max_occ, omega0, h, g_ratio, V,kappa, maxDim);
    ofstream save_file( file_obs) ;

    save_file << "# t";
    for(string name : name_obs) save_file << " . " + name;
    save_file << endl;

    save_file << setprecision(8);

    file_obs    = tinyformat::format("sx_RLC_N%d_maxocc%d_omega%.2f_h%.2f_gratio%.2f_V%.2f_kappa%.2f_maxDim%d.txt", N, max_occ, omega0, h, g_ratio, V,kappa, maxDim);
    ofstream save_file_sx( file_obs) ;
    save_file_sx << "# t";
    for(int j = 1 ; j<= N ; j++) save_file_sx << " . " + j;
    save_file_sx << endl;
    save_file_sx << setprecision(8);

    file_obs    = tinyformat::format("sz_RLC_N%d_maxocc%d_omega%.2f_h%.2f_gratio%.2f_V%.2f_kappa%.2f_maxDim%d.txt", N, max_occ, omega0, h, g_ratio, V,kappa, maxDim);
    ofstream save_file_sz( file_obs) ;
    save_file_sz << "# t";
    for(int j = 1 ; j<= N ; j++) save_file_sz << " . " + j;
    save_file_sz << endl;
    save_file_sz << setprecision(8);


    for(int k=0 ; k<total_steps ; k++)
    {
        double t = (k+1)*dt;

        // short-range interaction part Hamiltonian
        // no need of swap gates
        // cerr << "Applying single-site terms.\n";
        for (MyBondGate g : gates_matter)
        {
            vector<int> jn = g.jn();
            int j = *min_element(jn.begin(), jn.end());
            // change orthogonality center to minimize error
            psi_t.position(j);
            // apply gate
            ITensor AA = psi_t(j)*psi_t(j+1)*g.gate();
            auto [U,S,V] = svd(noPrime(AA),inds(psi_t(j)),{"Cutoff=",cut_off,"MaxDim=",maxDim});
            
            psi_t.set(j,U);
            psi_t.set(j+1,S*V);
        }

        // long range interaction gates -> need to swap gates (see https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.2.043255)
        // cerr << "Applying long-range photon matter interactions.\n";

        for (MyBondGate g : gates_pm)
        {   
            vector<int> jn = g.jn();
            int j1 = jn[0];
            int j2 = jn[1];

            // acting on ket part
            if(j1 < j2)
            {
                int j = j2;
                // change orthogonality center to minimize error
                psi_t.position(j);
                ITensor AA = psi_t(j-1)*psi_t(j)*g.gate();
                auto [U,S,V] = svd(noPrime(AA),inds(psi_t(j-1)),{"Cutoff=",cut_off,"MaxDim=",maxDim});
                
                psi_t.set(j-1,U);
                psi_t.set(j,S*V);
                
                swap_gate(&psi_t,j-1,j,cut_off,maxDim);
            }

            // acting on bra
            else
            {
                int j = j2;
                // change orthogonality center to minimize error
                psi_t.position(j);
                
                // apply gate
                ITensor AA = psi_t(j)*psi_t(j+1)*g.gate();
                auto [U,S,V] = svd(noPrime(AA),inds(psi_t(j)),{"Cutoff=",cut_off,"MaxDim=",maxDim});
                
                psi_t.set(j,U);
                psi_t.set(j+1,S*V);

                swap_gate(&psi_t,j,j+1,cut_off,maxDim);
            }                        
        }


        if(dissipative)
        {

            for (MyBondGateDiss gate : gates_D)
            {
                vector<int> jket = gate.jnket(); // sites where it acts on ket
                ITensor g        = gate.gate();
                int j = jket[0];
                ITensor AA = psi_t(j) * psi_t(j+1);
                ITensor dpsi =  g * AA;
                dpsi.mapPrime(1,0);
                AA = AA + dpsi;
                auto [U,S,V] = svd(AA,inds(psi_t(j)),{"Cutoff=",cut_off,"MaxDim=",maxDim});
                psi_t.set(j,U);
                psi_t.set(j+1,S*V);
            }

            // short-range interaction part Hamiltonian
            // no need of swap gates
            // cerr << "Applying single-site terms.\n";
            for (MyBondGate g : gates_matter)
            {
                vector<int> jn = g.jn();
                int j = *min_element(jn.begin(), jn.end());
                psi_t.position(j);
                ITensor AA = psi_t(j)*psi_t(j+1)*g.gate();
                auto [U,S,V] = svd(noPrime(AA),inds(psi_t(j)),{"Cutoff=",cut_off,"MaxDim=",maxDim});
                psi_t.set(j,U);
                psi_t.set(j+1,S*V);
            }

            // no need of swap gates
            for (MyBondGate g : gates_pm)
            {   
                vector<int> jn = g.jn();
                int j1 = jn[0];
                int j2 = jn[1];

                // acting on ket part
                if(j1 < j2)
                {
                    int j = j2;
                    // change orthogonality center to minimize error
                    psi_t.position(j);
                    // apply gate
                    ITensor AA = psi_t(j-1)*psi_t(j)*g.gate();
                    auto [U,S,V] = svd(noPrime(AA),inds(psi_t(j-1)),{"Cutoff=",cut_off,"MaxDim=",maxDim});
                    psi_t.set(j-1,U);
                    psi_t.set(j,S*V);
                    swap_gate(&psi_t,j-1,j,cut_off,maxDim);
                }

                // acting on bra
                else
                {
                    int j = j2;
                    psi_t.position(j);
                    ITensor AA = psi_t(j)*psi_t(j+1)*g.gate();
                    auto [U,S,V] = svd(noPrime(AA),inds(psi_t(j)),{"Cutoff=",cut_off,"MaxDim=",maxDim});
                    psi_t.set(j,U);
                    psi_t.set(j+1,S*V);
                    swap_gate(&psi_t,j,j+1,cut_off,maxDim);
                }

                            
            }


        }

        if (k % steps_measure == 0)
        {
            norm = compute_norm_purifed_impurity(&psi_t);
            cerr << t << " " << norm << "\n";
            save_file << t << " " << norm;
            for(string name : name_obs)
            {
                
                if(name=="Sx")
                {
                    mj_x  = measure_local_obs_impurity_first_site(&psi_t , Sx, false, 2);
                    save_file << " " << real(mj_x[0])/norm; 
                }

                if(name=="Sz")
                {
                    mj_z  = measure_local_obs_impurity_first_site(&psi_t , Sz, false, 2);
                    save_file << " " << real(mj_z[0])/norm; 
                }

                if(name=="Na")
                {
                    number_photons = measure_local_obs_impurity_first_site(&psi_t , Nb, false, 1);
                    save_file << " " << real(number_photons[0])/norm; 
                }
                if(name=="MaxD")
                {
                    save_file << " " << maxLinkDim(psi_t);
                }

                if(name=="local_obs")
                {
                    save_file_sx << t << " ";
                    save_file_sz << t << " ";
                
                    for(int j=1 ; j<= N; j++)
                    {
                        mj_x  = measure_local_obs_impurity_first_site(&psi_t , Sx, false, j+1);
                        mj_z  = measure_local_obs_impurity_first_site(&psi_t , Sz, false, j+1);
                        save_file_sx << " " << real(mj_x[0])/norm; 
                        save_file_sz << " " << real(mj_z[0])/norm; 
                    }
                    
                    save_file_sx << "\n";
                    save_file_sz << "\n";   
                }

            }
            save_file << "\n";
            save_file.flush();
            save_file_sx.flush();
            save_file_sz.flush();
        }
        
    }       

    save_file.close();
    save_file_sx.close();
    save_file_sz.close();

    return 0;

}